<!DOCTYPE html>
<html>

<head>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            align-items: flex-start;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .canvas-container {
            height: 640px;
            width: 640px;
            position: relative;
        }

        #gameCanvas {
            border: 2px solid #333;
            border-radius: 5px;
        }

        #startScreen {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            z-index: 1;
        }

        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            z-index: 1;
        }

        .score-container {
            margin-left: 30px;
            min-width: 250px;
            max-height: 640px;
            overflow-y: auto;
        }

        #score {
            font-size: 1.2em;
            color: #333;
            margin-bottom: 8px;
            padding: 8px;
            background-color: #f8f8f8;
        }

        .highscores-title {
            font-size: 1em;
            color: #333;
            padding: 8px;
            margin-bottom: 5px;
        }

        #highScoreForm {
            display: none;
            background-color: #f8f8f8;
            padding: 8px;
            border-radius: 5px;
        }

        #playerNameInput {
            font-family: 'Press Start 2P', cursive;
            padding: 8px;
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
            border: 2px solid #333;
            border-radius: 3px;
            width: 220px;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        #highScoresList {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        #highScoresList li {
            padding: 4px 8px;
            margin-bottom: 5px;
            background-color: #f8f8f8;
            border-radius: 3px;
            font-size: 0.8em;
        }

        #highScoresList li:nth-child(odd) {
            background-color: #f0f0f0;
        }
    </style>
</head>

<body>
    <div class="game-container">
        <div class="canvas-container">
            <canvas id="gameCanvas" width="640" height="640"></canvas>
            <div id="startScreen">
                <h2>Truck Snake</h2>
                <button onclick="startGamePlay()">Start Game</button>
            </div>
            <div id="gameOver">
                <h2>Game Over</h2>
                <button onclick="restartGame()">Retry</button>
            </div>
        </div>

        <div class="score-container">
            <div id="score">Score: 0</div>
            <div class="highscores-title">Highscores:</div>
            <form id="highScoreForm">
                <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="10">
                <button type="submit">Submit highscore</button>
            </form>
            <ol id="highScoresList"></ol>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        let truck = [{ top: 160, left: 160 }];
        let direction = 'RIGHT';
        let container = null;
        let myInterval = null;
        let score = 0;
        let lowestHighScore = 0;
        let gameStarted = false;
        let imgHead = new Image();
        let imgHeadLeft = new Image();
        let imgHeadUp = new Image();
        let imgHeadDown = new Image();
        let imgBodyHorizontal = new Image();
        let imgBodyVertical = new Image();
        let imgContainerSmall = new Image();
        let imgContainerLarge = new Image();
        let highScoreForm = document.getElementById('highScoreForm');
        imgHead.src = 'assets/truck_r.svg';
        imgBodyHorizontal.src = 'assets/trailer_h.svg';
        imgBodyVertical.src = 'assets/trailer_v.svg';
        imgHeadLeft.src = 'assets/truck_l.svg';
        imgHeadUp.src = 'assets/truck_u.svg';
        imgHeadDown.src = 'assets/truck_d.svg';
        imgContainerSmall.src = 'assets/ST_KEI_small.svg';
        imgContainerLarge.src = 'assets/OSBX_small.svg';
        
        let intervalTime = 200;
        const stepSize = 32; // Updated to match new sprite size

        function updateContainer() {
            let top = Math.round(Math.random() * (canvas.height - 64) / 32) * 32;
            let left = Math.round(Math.random() * (canvas.width - 64) / 32) * 32;
            const isBig = Math.random() < 0.2;
            const containerWidth = isBig ? 64 : 32;

            // Ensure container is not placed on top of any truck segment
            let attempts = 0;
            while (attempts < 100 && truck.some(segment => {
                // Check if container overlaps with this segment
                return !(
                    left + containerWidth <= segment.left ||
                    left >= segment.left + 32 ||
                    top + 32 <= segment.top ||
                    top >= segment.top + 32
                );
            })) {
                top = Math.round(Math.random() * (canvas.height - 64) / 32) * 32;
                left = Math.round(Math.random() * (canvas.width - 64) / 32) * 32;
                attempts++;
            }

            container = { top, left, isBig };
        }

        function updateTruck() {
            const head = Object.assign({}, truck[0]);

            switch (direction) {
                case 'LEFT':
                    head.left -= stepSize;
                    break;
                case 'RIGHT':
                    head.left += stepSize;
                    break;
                case 'DOWN':
                    head.top += stepSize;
                    break;
                case 'UP':
                    head.top -= stepSize;
                    break;
            }

            // Check if truck collides with itself or hits the boundary
            if (
                head.top < 0 ||
                head.left < 0 ||
                head.top >= canvas.height ||
                head.left >= canvas.width ||
                truck.slice(1).some(dot => dot.top === head.top && dot.left === head.left)
            ) {
                gameOver();
                return;
            }

            truck.unshift(head);

            // Improved container collision detection
            if (container) {
                const containerWidth = container.isBig ? 64 : 32;
                const containerHeight = 32;
                
                // Check if the truck's head overlaps with the container
                const overlap = !(
                    head.left + 32 <= container.left ||
                    head.left >= container.left + containerWidth ||
                    head.top + 32 <= container.top ||
                    head.top >= container.top + containerHeight
                );

                if (overlap) {
                    if (container.isBig) {
                        const tail = Object.assign({}, truck[truck.length - 1]);
                        truck.push(tail);
                    }
                    updateScore();
                    updateContainer();
                } else {
                    truck.pop();
                }
            } else {
                truck.pop();
            }
        }

        function gameOver() {
            // Get the high scores from local storage
            let highScores = JSON.parse(localStorage.getItem('truck-snake-highScores')) || [];
            
            // Determine the lowest high score
            if (highScores.length > 0) {
                lowestHighScore = highScores[highScores.length - 1].score;
            } else {
                lowestHighScore = 0;
            }

            // Check if the current score qualifies for high score list
            if (score > lowestHighScore || highScores.length < 10) {
                document.getElementById('highScoreForm').style.display = 'block';
            } else {
                displayHighScores();
            }
            clearInterval(myInterval);
            document.getElementById('gameOver').style.display = 'block';
        }

        function renderTruck() {
            let truckImg = imgHead;
            if (direction === 'LEFT') {
                truckImg = imgHeadLeft;
            } else if (direction === 'UP') {
                truckImg = imgHeadUp;
            } else if (direction === 'DOWN') {
                truckImg = imgHeadDown;
            }

            context.drawImage(truckImg, truck[0].left, truck[0].top, 32, 32);

            // Start from the second block of the truck
            for (let i = 1; i < truck.length; i++) {
                // Determine trailer orientation based on adjacent segments
                let trailerImg = imgBodyHorizontal;
                
                if (i < truck.length - 1) {
                    // Check direction between current segment and next segment
                    const dx = truck[i + 1].left - truck[i].left;
                    const dy = truck[i + 1].top - truck[i].top;
                    
                    if (dy !== 0) {
                        trailerImg = imgBodyVertical;
                    }
                } else {
                    // For the last segment, check direction from previous segment
                    const dx = truck[i].left - truck[i - 1].left;
                    const dy = truck[i].top - truck[i - 1].top;
                    
                    if (dy !== 0) {
                        trailerImg = imgBodyVertical;
                    }
                }
                
                context.drawImage(trailerImg, truck[i].left, truck[i].top, 32, 32);
            }
        }

        function draw() {
            context.clearRect(0, 0, canvas.width, canvas.height);

            renderTruck();

            if (container) {
                let img = imgContainerSmall
                if (container.isBig) {
                    img = imgContainerLarge
                }
                context.drawImage(img, container.left, container.top, container.isBig ? 64 : 32, 32);
            }
        }

        function updateScore() {
            score += 1; // Increment score
            document.getElementById('score').innerText = `Score: ${score}`;
            // Increase speed gradually every 5 points with diminishing returns
            if (score % 5 === 0) {
                intervalTime = Math.max(80, intervalTime - 15); // Decrease interval time but not below 80ms
                restartInterval();
            }
        }

        function restartInterval() {
            clearInterval(myInterval);
            myInterval = setInterval(() => {
                updateTruck();
                draw();
            }, intervalTime);
        }

        function saveHighScore() {
            let playerNameInput = document.getElementById('playerNameInput');
            let playerName = playerNameInput.value.trim();
            if (playerName !== '') {
                let highScores = JSON.parse(localStorage.getItem('truck-snake-highScores')) || [];
                highScores.push({ name: playerName, score: score });
                highScores.sort((a, b) => b.score - a.score);
                highScores = highScores.slice(0, 10);
                localStorage.setItem('truck-snake-highScores', JSON.stringify(highScores));
                displayHighScores();
                document.getElementById('highScoreForm').style.display = 'none';
            }
        }

        function displayHighScores() {
            // Get the high scores from local storage
            let highScores = JSON.parse(localStorage.getItem('truck-snake-highScores')) || [];
            // Display the high scores in a list
            let scoresList = document.getElementById('highScoresList'); // Replace with the ID of your high scores list element
            scoresList.innerHTML = '';

            if (highScores.length > 0) {
                lowestHighScore = highScores[highScores.length - 1].score;
            }

            highScores.forEach((score, index) => {
                let li = document.createElement('li');
                li.textContent = `${score.name} - ${score.score}`;
                scoresList.appendChild(li);
            });
        }

        function clearGame() {
            truck = [{ top: 160, left: 160 }];
            score = 0; // Reset score
            document.getElementById('score').innerText = `Score: ${score}`;
            direction = 'RIGHT';
            intervalTime = 200; // Reset interval time
        }

        window.addEventListener('keydown', e => {
            // Prevent 180-degree reversals
            const opposites = {
                'LEFT': 'RIGHT',
                'RIGHT': 'LEFT',
                'UP': 'DOWN',
                'DOWN': 'UP'
            };
            
            let newDirection = direction;
            switch (e.key) {
                case 'ArrowLeft':
                    newDirection = 'LEFT';
                    break;
                case 'ArrowRight':
                    newDirection = 'RIGHT';
                    break;
                case 'ArrowDown':
                    newDirection = 'DOWN';
                    break;
                case 'ArrowUp':
                    newDirection = 'UP';
                    break;
            }
            
            // Only change direction if it's not the opposite direction
            if (opposites[direction] !== newDirection) {
                direction = newDirection;
            }
        });

        highScoreForm.addEventListener('submit', function(event) {
            event.preventDefault();
            saveHighScore();
        });

        function restartGame() {
            container = null;
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('highScoreForm').style.display = 'none';
            clearGame();
            gameStarted = false;
            startGamePlay();
        }

        function initGame() {
            displayHighScores();
            
            // Wait for all images to load
            const imagePromises = [imgHead, imgBodyHorizontal, imgBodyVertical, imgHeadLeft, imgHeadUp, imgHeadDown, imgContainerLarge, imgContainerSmall].map(img => {
                if (img.complete) {
                    return Promise.resolve();
                }
                return new Promise((resolve) => {
                    img.onload = resolve;
                    img.onerror = resolve; // Resolve even on error to prevent hanging
                });
            });
            
            Promise.all(imagePromises).then(() => {
                // Images loaded, ready to start
            });
        }

        function startGamePlay() {
            if (gameStarted) return;
            
            gameStarted = true;
            document.getElementById('startScreen').style.display = 'none';
            updateContainer();
            
            myInterval = setInterval(() => {
                updateTruck();
                draw();
            }, intervalTime);
        }

        initGame();
    </script>
</body>

</html>